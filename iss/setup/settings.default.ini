; Default parameters
;
; Do not modify this file!  If you would like to change a value, create a new
; settings.ini file and set only the parameters you would like to be different
; than those found in this file.


[file_names]
; directory where raw nd2 files are
input_dir =

; directory where data saved
output_dir =

; directory where tile tiff files saved
tile_dir =

; Names of nd2 files for the rounds
round =

; Name of the file for the anchor round
anchor =

;
raw_extension = .nd2

; if true, tile and channel index in tile names will start at 1 else start at 0.
matlab_tile_names = False

; can be a tiff file indicating average spot shape, otherwise if deconvolution required, will be computed automatically
; in extract step (this is psf before tapering and scaled to fill uint16 range).
psf =


[basic_info]
; Whether to use the 3d pipeline.
3d =

; Channel that has most spots in anchor round (Starting from 0)
anchor_channel =

; Channel in anchor round that contains Dapi images (Starting from 0)
dapi_channel =

; will be set to anchor_round if anchor_channel and anchor file specified
ref_round =

; will be set to anchor_channel if anchor_channel and anchor file specified
ref_channel =
use_channels =
use_rounds =
use_z =
use_tiles =

; tile_pixel_value_shift is added onto every tile (except DAPI) when it is saved and
; removed from every tile when loaded so we can have negative pixel values. Saves as uint16.
tile_pixel_value_shift = 15000

; Previously had cases where first z plane in nd2 file was in wrong place and
; caused focus stacking to be weird or identify lots of spots on first plane
; hence safest to not load first plane which is done if this is True.
ignore_first_z_plane = True


[extract]
; time to wait for raw data to come in before crashing
; assume first round is already in the input_directory
; Want this large so can run pipeline while collecting data.
wait_time = 21600

; These specify the dimensions of the convolve_2d. R1 should be approximately the
; size of the spot (in pixels) in the respective direction and R2 should be double this (in pixels).
; Leave empty to auto-detect.
r1 =
r2 =

; radius of DAPI convolve_2d in units of pixels
r_dapi =

; if r1 and r_dapi not specified. Will convert to units of pixels from
; these micron values
; if r2 not specified, it will be twice r1.
r1_auto_microns = 0.5
r_dapi_auto_microns = 8.0


; Each filtered image is multiplied by scale. This is
; because the image is saved as uint16 so to gain information from
; the decimal points, should multiply image so max pixel number is
; in the 10,000s (less than 65,536).

; Normalization factor for the tiff images.  Leave empty to auto-detect.
scale =

; If scale not given, it sets to
; scale_norm/max(Tile ExtractScaleTile, round 0).
scale_norm = 40000

; Have different normalisation for anchor round/anchor channel as not
; used in final spot_colors
scale_anchor =

; auto_thresh[t,r,c] is default threshold to find spots on tile t, round r, channel c
; value of auto_thresh is auto_thresh_multiplier*median(abs(ScaledFilteredTile)).
auto_thresh_multiplier = 10

; for 3d pipeline, whether to perform deconvolution before hanning filtering
deconvolve  = False

; to detect spot, pixel needs to be above dilation with this radius in xy plane
psf_detect_radius_xy = 2

; to detect spot, pixel needs to be above dilation with this radius in z direction
psf_detect_radius_z = 1

; spots contribute to psf if they are above this intensity. If not given, will be computed the same as auto_thresh
; i.e. median(image) + auto_thresh_multiplier*median(abs(image-median(image)))
; note that for raw data, median(image) is not zero hence the difference.
psf_intensity_thresh =

; spots contribute to psf if more than psf_isolation_dist from nearest spot.
psf_isolation_dist = 20

; need this many isolated spots to determine psf
psf_min_spots = 300

; diameter of psf in y, x, z direction (in units of [xy_pixels, xy_pixels, z_pixels]).
psf_shape = 181, 181, 19

; psf is assumed to be radially symmetric within each z-plane so assume all values within annulus of this size
; (in xy_pixels) to be the same.
psf_annulus_width = 1.4

; TODO: auto way of determining this
wiener_constant = 50000

; pad to raw image to median value linearly with this many pixels at end of each dimension
wiener_pad_shape = 20, 20, 3


[find_spots]
; to detect spot, pixel needs to be above dilation with this radius in xy plane
radius_xy = 2

; to detect spot, pixel needs to be above dilation with this radius in z direction
radius_z = 1

; if number of spots detected on particular imaging round is greater than
; this, then will only select the max_spots most intense
; spots. I.e. PCR works better if trying to fit fewer more intense
; spots. This only applies to imaging rounds and not reference round
; and channel as need lots of spots for this image.
max_spots = 1500

; filter to determine if spots are isolated is annulus between isolation_radius_inner and isolation_radius
isolation_radius_inner = 4
isolation_radius_xy = 14
isolation_radius_z = 1

; spot is isolated if value of annular filtered image at spot location is below the isolation_thresh value.
; if not given, then value will be set to auto_isolation_thresh_multiplier multiplied by the threshold used
; to detect the spots i.e. the extract_auto_thresh value.
isolation_thresh =
auto_isolation_thresh_multiplier = -0.2

[stitch]

; expected fractional overlap between tiles. Used to get initial shift search if not provided
expected_overlap = 0.1

; if shift_south, shift_east not given, the initial shift search will have auto_n_shifts either side of the expected
; shift given the expected_overlap with step given by shift_step.
; First value gives n_shifts in direction of overlap (y for south, x for west).
; Second value gives n_shifts in other direction (x for south, y for west).
; Third value gives n_shifts in z.
auto_n_shifts = 20, 20, 1

; below gives an option to manually specify initial shifts. Shift range will run between min to max
; with step given by shift_step. Each entry should be a list of 3 values: [y, x, z].

; Typical: [-1900, -100, -2]
shift_south_min =

; Typical: [-1700, 100, 2]
shift_south_max =

; Typical: [-100, -1900, -2]
shift_west_min =

; Typical: [100, -1700, 2]
shift_west_max =

; step size to use in y, x, z when finding shift between tiles
shift_step = 5, 5, 2

; if shift in initial search range has score which does not exceed shift_score_thresh, then range will be extrapolated
; with same step by shift_widen values in y, x, z direction.
shift_widen = 10, 10, 4

; basically the distance in yx pixels below which neighbours are a good match.
neighb_dist_thresh = 2

; a shift between tiles must have a number of close neighbours exceeding this.
; if not given, it will be worked out as median + shift_score_auto_param*IQR of search scores.
shift_score_thresh =

; parameter to work out shift_score_thresh if not given
shift_score_auto_param = 5


[register_initial]
; channel to use to find shifts between rounds to use as starting point for PCR.
; if not selected, will set to reference_channel.
shift_channel =

; Shift range will run between min to max with step given by shift_step.
; Each entry should be a list of 3 values: [y, x, z].

; Typical: [-100, -100, -1]
shift_min = -100, -100, -1

; Typical: [100, 100, 1]
shift_max = 100, 100, 1

; step size to use in y, x, z when finding shift between tiles
shift_step = 5, 5, 2

; if shift in initial search range has score which does not exceed shift_score_thresh, then range will be extrapolated
; with same step by shift_widen values in y, x, z direction.
shift_widen = 20, 20, 2

; basically the distance in yx pixels below which neighbours are a good match.
neighb_dist_thresh = 2

; a shift between tiles must have a number of close neighbours exceeding this.
; if not given, it will be worked out as median + shift_score_auto_param*IQR of search scores.
shift_score_thresh =

; parameter to work out shift_score_thresh if not given
shift_score_auto_param = 5


